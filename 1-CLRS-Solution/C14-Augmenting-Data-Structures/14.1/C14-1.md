# Dynamic order statistics

## 1. 复习

C9介绍了一种在线性时间复杂度O(n)的情况下查找一个元素，本节介绍将数据组织为红黑树的情况下，我们查找一个元素的顺序统计量将降低到O(lgn)。

顺序统计量的O(n)的算法是工作在任意的集合上的，思想主要是每一次都缩小一定的查询范围，递归得去查找。我们红黑树已经按序组织好了各个元素，所以理论上可以达到更低的下届。

## 2. 问题描述

给一棵含有n个元素的红黑树T，中序遍历的结果是<x1, x2, x3,...xn>,对应的下标为<1,2,3,...n>。任意给一个待查元素x，得到它中序遍历结果的下标。（使用中序遍历这样的定义避免了遇到相同元素该输出几的困难）

## 3. 扩展红黑树

很容易想到给节点增加属性：它的顺序统计值，因为查找一个元素的复杂度是O(lgn)，这样找到这个元素的同时我们也就得到了它的顺序统计量，也是O(lgn)。看似很美好的设想，不过我们应该注意到，维护红黑树节点的这个属性会变得很困难。设想插入一个新节点，它比根节点要小， 所以你会插入左子树当中，但这时候，右子树和根节点的全部统计量都会加1，可以说平均情况至少有一半的节点需要更新，插入操作的复杂度变成了O(n)，显然是不被期望的。

算法导论中给了我们一个很好的很简单的方法来完成这件事情，代替记录统计量，我们记录以此节点为根节点的子树的大小。很容易得到这个属性的计算方法：x.size = x.left.size + x.right.size + 1。如果x是叶子节点，则x.size = 1。

## 4.扩展操作

我们需要两个操作，给一个元素，返回它是第几个元素；给一个名次，返回这个名次的元素是多少。首先来看第一个操作：返回一个元素的名词就是返回有多少个元素比他小，如果根节点就是这个元素得话，那么他的左子树的大小就是他的名次；如果这个元素比根节点更大，那么应该向右子树行走，将右子树节点当作新的根节点，并且所求的名次应该减少左子树元素数目加一的大小；反之，向左子树行走，名次大小不变。
