## 15.1
有向无环图中最长简单路径\
首先这个描述肯定是具有最优子结构的。因为无环，子问题之间相互独立。\
见code

## 15.2
最长回文字串\
leetcode上做过这道题，最长回文字串，见code

## 15.3
按照x的大小排列数组，考虑前k个数构成的环路，到k+1个数子构成环路时候，前k个数字构成的环路是否具有最优子结构呢？答案是没有，因为考虑从第k个数字向右走的第一个数字和向第k个数字走的最后一个数字，这两个数字可以发生变化，但是还是只有n种变化，所以，到第k+1的环路长度就等于n种到第k个环路长度种最短的。也就是每个子问题可以用两个点开标识。代码见code

## 15.4
最优子结构：最佳打印少一行的是少一行单词后空格最少的（包括行尾空格）。对最后一行可能的n种情况每一种计算取最小。

## 15.5
编辑距离，在Leetcode上做过简化版本。最优子结构：换成结果的最后一步之前的状态也一定是从开始到那会消费最小的状态。而最后一步可以是：
* 插入：dp[i][j] = dp[i][j-1] + cost(insert); 
* 复制：dp[i][j] = dp[i-1][j-1] + cost(copy), x[i] = y[j];
* 替换：dp[i][j] = dp[i-1][j-1] + cost(replace);
* 删除：dp[i][j] = dp[i-1][j] + cost(delete);
* 交换：dp[i][j] = dp[i-2][j-2] + cost(Twiddle), x[i-1] = y[j], x[i] = y[j-1];
* 结束：dp[i][j] = min(dp[k][j] + cost(kill)), k <-(0, i), z = y;

从这些结果中选取最小的。代码见code

第二小题：\
    使用copy,insert,replace,delete四种操作，cost(copy) = -1, cost(insert) = 2, cost(delete) = 2, cost(replace) = 1;

## 15.6
考虑，结果等于最高领导人被包含时候的最大，和最高领导人不被包含时候的最大，其中最高领导人被包含的最大等于它全部儿子不被包含的最大，最高领导人被包含的最大等于每一个儿子被包含或者不被包含的最大加起来。这样得话一共有2*n个子问题，很好。每个子问题处理所需要的时间为它的儿子数。O(n).见code

## 15.7
暂时没看懂题。。。。。。

## 15.8
a. 3^m\
b. 到第i行第j列的最低耗费就等于到它两个对角线的最低耗费和正上方的最低耗费中最小的加上这个值的耗费。这样算到最后一行，取最后一行中最小的。这样是O(mn)的

## 15.9
dp[i][j]表示把i到j切成满足题意的解的最小步数。所以
* dp[i][j+1] = min(dp[i][k] + dp[k][j+1] + 最后一刀切之前的长度（一个定值）)
n^2个子问题，每个子问题需要n所以是n^3

## 15.10 
* 显而易见
* dp[i][j]表示第i年使用第j种投资方式可以获得的最大收益，dp[i][j] = max(dp[i-1][j]-f1 * rij,dp[i-1][k]-f2 * rij);
* O(years * n*n)
* ...

## 15.11
## 15.12
题太长而不读